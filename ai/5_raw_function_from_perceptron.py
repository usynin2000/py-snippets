

# Ранее в 4_perception_usage мы сделали перцептрон для модерации комментариев
# Вот итоги:
# Epoch 5 finished
# Total errors this epoch: 0
# Weights now: [-0.2, -0.1, 0.1, -0.1]
# Bias now: 0.0


# Мы не знали какие параметры на что влияет, 
# 1. хорошо ли иметь длинный текст или плохо,
# 2. хорошо ли иметь ссылку или плохо,
# 3. хорошо ли иметь мат или плохо,
# 4. хорошо ли иметь новый пользователь или плохо,

# Мы прогнали имеющиуеся данные через перцептрон и получили веса для каждого параметра
# Теперь мы можем использовать эти веса для нового комментария
# Мы можем использовать эту функцию для модерации комментариев

# Функция будет выглядеть вот так: 
def moderate(x):
    score = (
        -0.2 * x[0] +
        -0.1 * x[1] +
         0.1 * x[2] +
        -0.1 * x[3] +
         0.0
    )
    return 1 if score >= 0 else 0

# Теперь мы можем использовать эту функцию для модерации комментариев
# Например, если у нас есть комментарий:
# x = [1, 1, 0, 1]
# То мы можем использовать эту функцию для модерации комментариев
# print(moderate(x))
# Вывод: 0
# То есть комментарий будет модерирован как плохой
# Если у нас есть комментарий:
# x = [0, 0, 0, 0]
# То мы можем использовать эту функцию для модерации комментариев
# print(moderate(x))


tests = [
    ([0, 0, 1, 0], 1),
    ([1, 0, 0, 0], 0),
    ([0, 1, 1, 1], 0),
]

for x, y in tests:
    print(x, "→", moderate(x), "(expected:", y, ")")




# Теперь мы можем использовать эту функцию для объяснения модерации комментариев
# Например, если у нас есть комментарий:
# x = [1, 1, 0, 1]
# То мы можем использовать эту функцию для объяснения модерации комментариев
# explain(x)
# Вывод: 
# x1 * w1 = 1 * -0.2 = -0.2
# x2 * w2 = 1 * -0.1 = -0.1

weights = [-0.2, -0.1, 0.1, -0.1]


def explain(x):
    for i, (w, xi) in enumerate(zip(weights, x), 1):
        print(f"x{i} * w{i} = {xi} * {w} = {xi * w}")


explain([1, 1, 0, 1])


# Что это за функция с точки зрения математики?
# - линейная функция
#     - порог (step function)
# f(x) = sign(w·x + 

# В 2D — это линия
# В 3D — плоскость
# В 4D — гиперплоскость

# Она делит мир на 2 части:
# - публикуем
# - модерируем


# Почему это реально используется

# Потому что:
# - быстро (O(n))
# - объяснимо
# - стабильно
# - легко дебажить
# - можно хранить в JSON
# {
#   "weights": [-0.2, -0.1, 0.1, -0.1],
#   "bias": -0.1
# }

# И загрузить при старте сервиса.


# Далее ограничения перцептрона
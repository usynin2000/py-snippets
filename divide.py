# Даны два целых числа — делимое и делитель.
# Необходимо выполнить деление этих чисел, не используя операторы умножения, деления и остатка от деления.
# Результат деления должен быть усечён к нулю, то есть дробная часть отбрасывается.
#
# Например: • 8.345 усечётся до 8 • -2.7335 усечётся до -2
# Нужно вернуть частное от деления делимого на делитель.
#
# Примечание: Считайте, что мы работаем в среде, где можно хранить только целые числа в диапазоне 32-битного знакового типа: [-2^{31}, 2^{31} - 1]
# Если результат строго больше, чем 2^{31} - 1, вернуть 2^{31} - 1. Если результат строго меньше, чем -2^{31}, вернуть -2^{31}.
#
# Пример 1: Вход: делимое = 10, делитель = 3 Выход: 3 Пояснение: 10 / 3 = 3.33333, усечённое значение 3.
#
# Пример 2: Вход: делимое = 7, делитель = -3 Выход:-2 Пояснение: 7 / -3 = -2.33333, усечённое значение -2. давай решим эту задачку








def divide(dividend: int, divisor: int) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31

    if dividend == INT_MAX and divisor == -1:
        return INT_MAX

    # Определяем знак
    # XOR — это сокращение от “exclusive or”, то есть исключающее ИЛИ.
    negative = (dividend < 0) ^ (divisor < 0) # ^ — это побитовое XOR для булевых значений, который работает как "различие":
                            # True ^ False → True
                            # False ^ True → True
                            # True ^ True → False
                            # False ^ False → False
    dividend, divisor = abs(dividend), abs(divisor)

    result = 0

    for i in range(31, -1, -1):
        # Мы идём от 31 до 0 (включительно) — это биты 32-битного числа.
        # Сначала пробуем вычесть самое большое кратное делителя, которое помещается в делимое.
        # Так мы сразу «срезаем» большие куски, не тратя время на постепенное вычитание.
        if (divisor << i) <= dividend:
            # divisor << i — это умножение делителя на 2^i (сдвиг влево на i бит).
            dividend -= divisor << i
            # Мы вычитаем найденный крупный кусок из делимого, чтобы продолжить деление на остатке.
            result += 1 << i

    if negative:
        result = - result

    return max(min(result, INT_MAX), INT_MIN)


if __name__ == "__main__":
    print(divide(10, 3))


# Что делает <<

# Сдвигаем все биты влево на i позиций, справа добавляются нули.

# | Действие | Двоично | Десятичное |
# | -------- | ------- | ---------- |
# | 3        | 11      | 3          |
# | 3 << 1   | 110     | 6          |
# | 3 << 2   | 1100    | 12         |
# | 3 << 3   | 11000   | 24         |

# То есть каждый сдвиг влево на 1 бит = умножение на 2.

# Как это помогает делению
#
# Мы ищем, сколько раз делитель помещается в делимое.


# Например, 10 / 3:
#
# Берём делитель 3 и сдвигаем биты, чтобы получить максимальное число ≤ 10:
#
# 3 << 1 = 6 (ещё помещается)
#
# 3 << 2 = 12 (уже больше 10, не годится)


# Вычитаем 6 из 10 → остаток 4.

# Теперь смотрим ещё раз сдвиги 3 << 0 = 3 ≤ 4 → вычитаем → остаток 1.

# Частное строится из этих «единиц» сдвигов:
#
# 1 << 1 = 2 → добавляем к результату
#
# 1 << 0 = 1 → добавляем к результату
#
# Итог: 2 + 1 = 3.
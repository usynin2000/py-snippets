# Apache Kafka — теория Message Queues

## Что такое Message Queue?

**Message Queue** (очередь сообщений) — паттерн асинхронной передачи данных, при котором отправитель (producer) и получатель (consumer) работают **независимо** друг от друга. Сообщения временно хранятся в брокере до момента обработки.

```
[Producer] → сообщение → [Broker/Queue] → [Consumer]
```

---

## Зачем нужны Message Queues?

| Проблема | Решение |
|----------|---------|
| Producer и Consumer должны быть онлайн одновременно | Брокер буферизует сообщения |
| Всплески нагрузки | Очередь сглаживает пики |
| Несколько consumers обрабатывают одни и те же данные | Pub/Sub: несколько подписчиков на один топик |
| Нужна надёжная доставка | Persistence: сообщения хранятся на диске |
| Масштабирование обработки | Партиции + Consumer Groups |

---

## Apache Kafka — основные концепции

### Топик (Topic)

**Топик** — именованный канал для сообщений определённого типа. Producer отправляет в топик, Consumer подписывается на него.

Примеры: `trading-events`, `user-events`, `critical-events`.

### Партиция (Partition)

Топик физически делится на **партиции** — упорядоченные, неизменяемые последовательности записей.

- **Порядок**: внутри одной партиции порядок сообщений гарантирован
- **Параллелизм**: разные партиции обрабатываются независимо
- **Масштабирование**: партиции распределяются между consumers

### Offset

**Offset** — уникальный идентификатор позиции сообщения внутри партиции. Consumer хранит offset последнего обработанного сообщения и читает дальше.

### Producer

**Producer** — приложение, которое записывает сообщения в топики Kafka.

- Может указать **ключ** (key) — сообщения с одинаковым ключом попадут в одну партицию
- Без ключа — round-robin между партициями
- `acks`: уровень подтверждения (0, 1, all)
- `value_serializer`: преобразование объекта в bytes

### Consumer

**Consumer** — приложение, которое читает сообщения из топиков.

- При чтении получает: `value`, `key`, `partition`, `offset`, `timestamp`
- `value_deserializer`: преобразование bytes в объект

### Consumer Group

**Consumer Group** — группа consumers, совместно обрабатывающих топик.

- Каждая **партиция** читается только **одним** consumer в группе
- При добавлении/удалении consumers Kafka автоматически перераспределяет партиции (rebalance)
- Offset хранится на уровне группы — каждая группа имеет свой прогресс чтения

```
Топик: 3 партиции (P0, P1, P2)
Группа: 2 consumers (C1, C2)

C1 читает: P0, P1
C2 читает: P2
```

---

## Сравнение с другими паттернами

| Паттерн | Связь | Пример |
|---------|-------|--------|
| **Request-Response** | Синхронная, парная | HTTP API |
| **Long Polling** | Клиент ждёт ответ | Веб-сокеты, SSE |
| **Message Queue** | Асинхронная, через брокер | Kafka, RabbitMQ |

---

## Особенности Kafka

- ✅ **High throughput** — миллионы сообщений в секунду
- ✅ **Persistence** — сообщения хранятся на диске (retention period)
- ✅ **Replay** — можно перечитать старые сообщения (изменить offset)
- ✅ **Horizontal scaling** — партиции распределяются по кластеру
- ✅ **At-least-once / Exactly-once** — семантика доставки настраивается

---

## Жизненный цикл сообщения

1. **Producer** создаёт сообщение, вызывает `send()` или `send_and_wait()`
2. Kafka **сериализует** и записывает в партицию (по ключу или round-robin)
3. Сообщение **сохраняется** на диск, реплицируется (если настроено)
4. **Consumer** получает сообщение через `async for`
5. Consumer **обрабатывает** сообщение
6. Consumer делает **commit** offset — Kafka запоминает прогресс
7. Следующее чтение начинается с `offset + 1`

---

## Семантика доставки

| Уровень | Описание | Риск |
|---------|----------|------|
| **At-most-once** | Отправили и забыли | Потеря сообщений |
| **At-least-once** | Retry до подтверждения | Дубликаты при сбое |
| **Exactly-once** | Идемпотентность + транзакции | Сложнее в настройке |

---

## Полезные ссылки

- [Apache Kafka Documentation](https://kafka.apache.org/documentation/)
- [aiokafka — async Kafka client for Python](https://aiokafka.readthedocs.io/)
